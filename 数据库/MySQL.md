
#### book
- 《高性能MySQL》第三版

#### 关系型数据库核心概念
- 数据行（记录）
- 数据列（字段）
- 数据表（数据行的集合）
- 数据库（数据表的集合）

#### RDBMS
- Relational Database Management System，通过表来表示关系型，关系型数据库管理系统

#### SQL
- Structured Query Language，结构化查询语言，是一种用来操作RDBMS的数据库语言
- SQL主要分为：
  - **DQL：数据查询语言，用于对数据进行查询，如select**
  - **DML：数据操作语言，对数据进行增加、修改、删除，如insert、update、delete**
  - TPL：事务处理语言，对事务进行处理，如begin、transaction、commit、rollback
  - DCL：数据控制语言，进行授权与权限回收，如grant、revoke
  - DDL：数据定义语言，进行数据库、表的管理等，如create、drop
  - CCL：指针控制语言，通过控制指针完成表的操作，如declare、cursor
- 约束：
  - 主键primary key：物理上存储的顺序
  - 非空not null
  - 唯一ubique
  - 默认default
  - 外键foreign key：一个表中的一个字段存储的是另一个表中的主键，这个字段就是外键

## MySQL的两层
大体来说，MySQL可以分为**Server层**和**存储引擎层**两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。

## 查询、更新语句的执行过程
![[Pasted image 20220823212810.png]]
1. **连接器**
连接器负责跟客户端建立连接、获取权限、维持和管理连接

2. **查询缓存**
连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

**但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**

需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。

3. **分析器**
词法分析
语法分析
如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。分析器。Oracle会在分析阶段判断语句是否正确，表是否存在，列是否存在等

4. **优化器**
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

5. **执行器**

## MySQL里面最重要的两个日志
物理日志redo log和逻辑日志binlog

这两种日志有以下三点不同。

1.  redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
    
2.  redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
    
3.  redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
    

有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。

1.  执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
    
2.  执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
    
3.  引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
    
4.  执行器生成这个操作的binlog，并把binlog写入磁盘。
    
5.  执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

## 事务
- 必须InnoDB引擎
- 所谓事务，就是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位
- 事务四大特性（简称ACID）
	1. 原子性（Atomicity）
	2. 一致性（Consistency）
	3. 隔离性（Isolation）
	4. 持久性（Durability）

简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。

### 隔离性
当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。

在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：

-   读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
-   读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
-   可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
-   串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。

## 索引
- 数据量超过300万时需要建立索引
- 索引是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针，目的：提升查询的效率

索引的常见模型：哈希表，有序数组和搜索树
**哈希表这种结构适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎。
**有序数组在等值查询和范围查询场景中的性能就都非常优秀**
如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。

### InnoDB 的索引模型
在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一棵B+树。

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。

根据上面的索引结构说明，我们来讨论一个问题：**基于主键索引和普通索引的查询有什么区别？**

-   如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
-   如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

### 索引维护
B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

## 查询(query)
1. C: Create      增
2. R: Read         查
3. U: Update     改
4. D: Delete       删

#### 链接查询
- 内连接查询：查询的结果为两个表匹配到的数据
- 右连接查询：查询的结果为两个表匹配到的数据和右表特有的数据，对于左表中不存在的数据使用null填充
- 左连接查询：查询的结果为两个表匹配到的数据和左表特有的数据，对于右表中不存在的数据使用null填充

#### 自关联

## 子查询
- 标量子查询
- 列级子查询
- 行级子查询

## select
- 完整的select语句为：
```sql
select distinct *
from 表名
where ....
group by ... having ...
order by ...
limit start,count
```
- 执行顺序为：
```SQL
from 表名
where ....
group by ...
select distinct *
having ...
order by ...
limit start,count 
```
- select语句的语法
![[Pasted image 20220808205756.png|1000]]
![[Pasted image 20220814213653.png|900]]

## E-R图
- 一对一
  - 实体A对实体B为1对1，在表A或表B中创建一个字段，存储另外一个表的主键
- 一对多
  - 实体A对实体B为一对多，在表B中创建一个字段，存储表A的主键值
- 多对多
  - 实体A对实体B为多对多，新建一张表，一个用于存储A的主键值，一个用于存储B的主键值

## 三范式
- 第一范式
  - 原子性：表的字段不可再拆分为更小的字段
- 第二范式
  - 在满足第一范式的基础上，非主键必须完全依赖主键，而不是只有部分非主键依赖于主键
- 第三范式
  - 如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。

## 视图
- 通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要工作就落在创建这条SQL查询语句上
- 视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本数据发生改变，视图也会跟着改变）
- creat view xxx as select ......

#### ORM
- 对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在互不匹配的现象的技术，主要实现程序对象到关系数据库数据的映射。
- 当前ORM框架主要有五种：
  （1）Hibernate 全自动 需要写hql语句
  （2）iBATIS 半自动 自己写sql语句,可操作性强,小巧
  （3）mybatis
  （4）eclipseLink
  （5）JFinal

#### 优化
- 垂直拆分
	- 读写分离，缓存能解决读的压力
- 水平拆分
	- 分库分表，解决写的压力
