
#### 进程
- 不共享任何状态
- 调度由操作系统完成
- 有独立的内存空间（上下文切换的时候需要保存栈、cpu寄存器、虚拟内存、以及打开的相关句柄等信息，开销大）
- 通讯主要通过信号传递的方式来实现（实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低）
- 一个task_struct结构体的实例变量代表一个Linux进程

Linux 进程调度支持多种调度算法，有基于优先级的调度算法，有实时调度算法，有完全公平调度算法（CFQ）。

CFS调度器的核心就是让虚拟时间最小的进程最先运行， 一旦进程运行虚拟时间就会增加，最后尽量保证所有进程的 虚拟时间相等，谁小了就要多运行，谁大了就要暂停运行。

为什么要用红黑树来组织调度实体（进程实体）？
这是因为要维护虚拟时间的顺序，又要从中频繁的删除和插入调度实体，这种情况下红黑树这种结构无疑是非常好。

#### 线程
- 共享变量（解决了通讯麻烦的问题，但是对于变量的访问需要加锁）
- 调度由操作系统完成（由于共享内存，上下文切换变得高效）
- 一个进程可以有多个线程，每个线程会共享父进程的资源（创建线程开销占用比进程小很多，可创建的数量也会很多）
- 通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信（通过共享内存通信比通过内核要快很多）

#### 协程
- 调度完全由用户控制
- 一个线程（进程）可以有多个协程
- 每个线程（进程）循环按照指定的任务清单顺序完成不同的任务（当任务被堵塞时，执行下一个任务；当恢复时，再回来执行这个任务；任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量）
- 协程需要保证是非堵塞的且没有相互依赖
- 协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高

#### 总结
- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)
- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度

## 内核线程
我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现 在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 systemd 来进行管理。

稍微想一下 Linux 中的各种进程，除了用户态进程外，还有大量的内核态线程。按说内核 态的线程，应该先于用户态进程启动，可是 systemd 只管理用户态进程。那么，内核态线 程又是谁来管理的呢？

实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。

- 0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后， 演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。

- 1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进 程。

- 2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。

##### 常见的内核线程
ksoftirqd：它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。

kswapd0：用于内存回收。在 Swap 变高 案例中，我曾介绍过它的工作原理。

kworker：用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU86330）和未绑定 CPU（名称格式为 kworker/uPOOL86330）两类。 migration：在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。

jbd2/sda1-8：jbd 是 Journaling Block Device 的缩写，用来为文件系统提供日志功 能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 jbd2 内核线程。

pdflush：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经 在 3.10 中合并入了 kworker 中）。

## 进程的状态
![[Pasted image 20220826160034.png]]
我们从这张图中可以看出来，在进程“活着”的时候就只有两个状态：运行态 （TASK_RUNNING）和睡眠态（TASK_INTERRUPTIBLE， TASK_UNINTERRUPTIBLE）。

运行态的意思是，无论进程是正在运行中（也就是获得了 CPU 资源），还是进程在 run queue 队列里随时可以运行，都处于这个状态。 我们想要查看进程是不是处于运行态，其实也很简单，比如使用 ps 命令，可以看到处于这 个状态的进程显示的是 R stat。

睡眠态是指，进程需要等待某个资源而进入的状态，要等待的资源可以是一个信号量 （Semaphore）, 或者是磁盘 I/O，这个状态的进程会被放入到 wait queue 队列里。

这个睡眠态具体还包括两个子状态：一个是可以被打断的（TASK_INTERRUPTIBLE），我 们用 ps 查看到的进程，显示为 S stat。还有一个是不可被打断的（TASK_UNINTERRUPTIBLE），用 ps 查看进程，就显示为 D stat。

除了上面进程在活的时候的两个状态，进程在调用 do_exit() 退出的时候，还有两个状态。 

一个是 EXIT_DEAD，也就是进程在真正结束退出的那一瞬间的状态；第二个是 EXIT_ZOMBIE 状态，这是进程在 EXIT_DEAD 前的一个状态，而我们今天讨论的僵尸进 程，也就是处于这个状态中。

#### 进程状态（TOP）
R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正 在等待运行。

D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
**不可中断状态**，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允 许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。

Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
**僵尸进程**表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状 态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有 正常处理子进程的退出。

S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件 而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。

I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交 互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任 何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。

T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。 向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向 它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪 状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的 运行。

X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令 中看到它。

## 僵尸进程
![[Pasted image 20220826165504.png]]
一个正常的进程退出流程是这样的：

-   子进程退出后，给父进程发送一个SIGCHLD的信号
-   父进程收到这个信号后，会通过wait系统调用来回收子进程

1. 僵尸进程产生原因：

僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源

当一个进程创建了一个子进程时，他们的运行是异步的。即父进程无法预知子进程会在什么时候结束，那么如果父进程很繁忙来不及wait 子进程时，那么当子进程结束时，会丢失子进程的结束时的状态信息，处于这种考虑unix提供了一种机制可以保证只要父进程想知道子进程结束时的信息，它就可以得到。

 这种机制是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是仍然保留了一些信息，留下一个称为僵尸进程（Zombie）的数据结构（如进程号pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用wait/waitpid时才会释放。这样就导致了一个问题，如果没有调用wait/waitpid的话，那么保留的信息就不会释放。

**“僵死状态”，指的是子进程退出后，在父进程使用wait对它进行回收之前的状态**。

正常情况下，当一个进程创建了子进程 后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。 如果父进程没这么做，或是子进程执行太快，父进程还没来得及处理子进程状态，子进程就 已经提前退出，那这时的子进程就会变成僵尸进程。

通常，僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退 出后，由 init 进程回收后也会消亡。 一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状 态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避 免。

2. 进程结束后为什么要进入僵尸状态?

因为父进程可能需要子进程的退出状态等信息。

3. 僵尸进程是每个子进程必经的状态吗？

是的。 任何一个子进程（init除外）在exit（）之后，并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit（）之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。

## 进程组和会话
进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员； 

会话是指共享同一个控制终端的一个或多个进程组。

比如，我们通过 SSH 登录服务器，就会打开一个控制终端（TTY），这个控制终端就对应 一个会话。而我们在终端中运行的命令以及它们的子进程，就构成了一个个的进程组，其中，在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。

## 进程地址空间
我们用一张图，来表示进程的地址空间。图的左侧是说进程可以通过什么方式来更改进程虚拟地址空间，而中间就是进程虚拟地址空间是如何划分的，右侧则是进程的虚拟地址空间所对应的物理内存或者说物理地址空间。
![[Pasted image 20220905165136.png|700]]

应用程序都是跟虚拟地址打交道，不会直接跟物理地址打交道。而虚拟地址最终都要转换为物理地址，由于 Linux 都是使用 Page（页）来进行管理的，所以这个过程叫 Paging（分页）。

![[Pasted image 20220905165246.png|700]]
进程运行所需要的内存类型有很多种，总的来说，这些内存类型可以从是不是文件映射， 以及是不是私有内存这两个不同的维度来做区分，也就是可以划分为上面所列的四类内存。
**私有匿名内存**。进程的堆、栈，以及 mmap(MAP_ANON | MAP_PRIVATE) 这种方式 申请的内存都属于这种类型的内存。其中栈是由操作系统来进行管理的，应用程序无需 关注它的申请和释放；堆和私有匿名映射则是由应用程序（程序员）来进行管理的，它 们的申请和释放都是由应用程序来负责的，所以它们是容易产生内存泄漏的地方。 

**共享匿名内存**。进程通过 mmap(MAP_ANON | MAP_SHARED) 这种方式来申请的内 存，比如说 tmpfs 和 shm。这个类型的内存也是由应用程序来进行管理的，所以也可 能会发生内存泄漏。 

**私有文件映射**。进程通过 mmap(MAP_FILE | MAP_PRIVATE) 这种方式来申请的内存， 比如进程将共享库（Shared libraries）和可执行文件的代码段（Text Segment）映射到自己的地址空间就是通过这种方式。对于共享库和可执行文件的代码段的映射，这是 通过操作系统来进行管理的，应用程序无需关注它们的申请和释放。而应用程序直接通 过 mmap(MAP_FILE | MAP_PRIVATE) 来申请的内存则是需要应用程序自己来进行管 理，这也是可能会发生内存泄漏的地方。

**共享文件映射**。进程通过 mmap(MAP_FILE | MAP_SHARED) 这种方式来申请的内存， 我们在上一个模块课程中讲到的 File Page Cache 就属于这类内存。这部分内存也需要应用程序来申请和释放，所以也存在内存泄漏的可能性.


![[Pasted image 20220905165519.png|700]]
如上图所示，**Paging 的大致过程是**，CPU 将要请求的虚拟地址传给 MMU（Memory Management Unit，内存管理单元），然后 MMU 先在高速缓存 TLB（Translation Lookaside Buffer，页表缓存）中查找转换关系，如果找到了相应的物理地址则直接访 问；如果找不到则在地址转换表（Page Table）里查找计算。最终进程访问的虚拟地址就 对应到了实际的物理地址。

#### 进程内存管理
进程直接读写的都是虚拟地址，虚拟地址最终会通过 Paging（分页）来转换为物理内存 的地址，Paging 这个过程是由内核来完成的。

进程的内存类型可以从 anon（匿名）与 file（文件）、private（私有）与 shared（共 享）这四项来区分为 4 种不同的类型，进程相关的所有内存都是这几种方式的不同组 合。

查看进程内存时，可以先使用 top 来看系统中各个进程的内存使用概况，再使用 pmap 去观察某个进程的内存细节。
![[Pasted image 20220905210037.png|800]]

### tmpfs
我们知道，磁盘的速度是远远低于内存的，有些应用程序为了提升性能，会避免将一些无需持续化存储的数据写入到磁盘，而是把这部分临时数据写入到内存中，然后定期或者在不需要这部分数据时，清理掉这部分内容来释放出内存。在这种需求下，就产生了一种特殊的 Shmem：tmpfs。tmpfs 如下图所示：
![[Pasted image 20220905212758.png|700]]
它是一种内存文件系统，只存在于内存中，它无需应用程序去申请和释放内存，而是操作 系统自动来规划好一部分空间，应用程序只需要往这里面写入数据就可以了，这样会很方 便。我们可以使用 moun 命令或者 df 命令来看系统中 tmpfs 的挂载点。

很多应用程序会把日志保存在tmpfs里，也有些应用会把它的运行时文件保存在tmpfs里。比如systemd就会把日志记录到tmpfs中。你可以用mount命令来查看你的系统tmpfs挂载 路径，然后去这里面查看有哪些文件，你也可以看出来你的系统里有哪些应用会用到tmpfs.

## 进程的虚拟地址空间
进程的虚拟地址空间（address space）既包括用户地址空间，也包括内核地址空间。这可以简单地理解为，进程运行在用户态申请的内存，对应的是用户地址空间，进程运行在内核态申请的内存，对应的是内核地址空间，如下图所示：
![[Pasted image 20220905214125.png|900]]
应用程序可以通过 malloc() 和 free() 在用户态申请和释放内存，与之对应，可以通过 kmalloc()/kfree() 以及 vmalloc()/vfree() 在内核态申请和释放内存。当然，还有其他申请 和释放内存的方法，但大致可以分为这两类。

从最右侧的物理内存中你可以看出这两类内存申请方式的主要区别，kmalloc() 内存的物理 地址是连续的，而 vmalloc() 内存的物理地址则是不连续的。这两种不同类型的内存也是 可以通过 /proc/meminfo 来观察的。

其中 vmalloc 申请的内存会体现在 VmallocUsed 这一项中，即已使用的 Vmalloc 区大小；而 kmalloc 申请的内存则是体现在 Slab 这一项中，它又分为两部分，其中 SReclaimable 是指在内存紧张的时候可以被回收的内存，而 SUnreclaim 则是不可以被回 收只能主动释放的内存。


## 信号
kill -l查看linux所有信号

如果我们按下键盘“Ctrl+C”，当前运行的进程就会收到一个信号 SIGINT 而退出；

如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号 SIGSEGV；

我们也可以通过命令 kill ，直接向一个进程发送一个信号，缺省情况下不指定信 号的类型，那么这个信号就是 SIGTERM。也可以指定信号类型，比如命令 “kill -9 ”, 这里的 9，就是编号为 9 的信号，SIGKILL 信号。

目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作 为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程，也就是1号进程。

![[Pasted image 20220826111104.png|700]]
对 于 SIGKILL 和 SIGSTOP 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是 为 Linux kernel 和超级用户提供删除任意进程的特权。对于捕获，SIGKILL 和 SIGSTOP 这两个信号也同样例外，这两个信号不能有用户自己的 处理代码，只能执行系统的缺省行为。这两个特权信号，不能被忽略也不能被捕获。

对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就 可以了。对于每个信号，用户进程如果不注册一个自己的 handler，就会 有一个系统缺省的 handler，这个缺省的 handler 就叫作 SIG_DFL。

![[Pasted image 20220826111951.png|700]]

## 并发操作中，linux解决数据同步的四种方法
#### 1.原子变量
在只有单个变量全局数据的情况下，这种变量非常实用，如全局计数器、状 态标志变量等。我们利用了 CPU 的原子指令实现了一组操作原子变量的函数。 

#### 2.中断的控制
当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在 单核心的 CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会 有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就 行了，为此我们开发了控制中断的函数。 

中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来 请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按 下了键盘上的某个按键、硬盘已经准备好了数据。

#### 3.自旋锁
由于多核心的 CPU 出现，控制中断已经失效了，因为系统中同时有多个代码执 行流，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待 最终获取锁。 

首先读取锁变量，判断其值是否已经加锁，如果 未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执 行后续步骤，因而得名自旋锁。

![[Pasted image 20220901091240.png|400]]
linux有多种自旋锁，例如原始自旋锁和排队自旋锁等

#### 4.信号量
如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都 不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获 取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让 CPU 能有时间 处理其它任务。所以信号量同时解决了三个问题：等待、互斥、唤醒。

Linux 中的信号量同样是用来保护共享资源，能保证资源在一个时刻只有一个进程使用，这 是单值信号量。也可以作为资源计数器，比如一种资源有五份，同时最多可以有五个进 程，这是多值信号量。

单值信号量，类比于私人空间一次只进去一个人，其信号量的值初始值为 1，而多值信号量，相当于是客厅，可同时容纳多个人。其信号量的值初始值为 5，就可容纳 5 个人。 

信号量的值为正的时候。所申请的进程可以锁定使用它。若为 0，说明它被其它进程占 用，申请的进程要进入睡眠队列中，等待被唤醒。所以信号量最大的优势是既可以使申请 失败的进程睡眠，还可以作为资源计数器使用。

#### 5.读写锁
在操作系统中，有很多共享数据，进程对这些共享数据要进行修改的情况很少，而读取的 情况却是非常多的，这些共享数据的操作基本都是在读取。 

如果每次读取这些共享数据都加锁的话，那就太浪费时间了，会降低进程的运行效率。因 为读操作不会导致修改数据，所以在读取数据的时候不用加锁了，而是可以共享的访问， 只有涉及到对共享数据修改的时候，才需要加锁互斥访问。 

想像一下 100 个进程同时读取一个共享数据，而每个进程都要加锁解锁，剩下的进程只能 等待，这会大大降低整个系统性能，这时候就需要使用一种新的锁了——读写锁。 

读写锁也称为共享 - 独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以 共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥）。 

读写锁非常适合读取数据的频率远大于修改数据的频率的场景中。这样可以在任何时刻， 保证多个进程的读取操作并发地执行，给系统带来了更高的并发度。 

那读写锁是怎么工作的呢？读写之间是互斥的，读取的时候不能写入，写入的时候不能读 取，而且读取和写入操作在竞争锁的时候，写会优先得到锁，步骤如下。 

1. 当共享数据没有锁的时候，读取的加锁操作和写入的加锁操作都可以满足。
2. 当共享数据有读锁的时候，所有的读取加锁操作都可以满足，写入的加锁操作不能满足，读写是互斥的。
3. 当共享数据有写锁的时候，所有的读取的加锁操作都不能满足，所有的写入的加锁操作 也不能满足，读与写之间是互斥的，写与写之间也是互斥的。

![[Pasted image 20220901094226.png|600]]

