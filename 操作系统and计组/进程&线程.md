
#### 进程
- 不共享任何状态
- 调度由操作系统完成
- 有独立的内存空间（上下文切换的时候需要保存栈、cpu寄存器、虚拟内存、以及打开的相关句柄等信息，开销大）
- 通讯主要通过信号传递的方式来实现（实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低）
- 一个task_struct结构体的实例变量代表一个Linux进程
- Linux 进程调度支持多种调 度算法，有基于优先级的调度算法，有实时调度算法，有完全公平调度算法（CFQ）。

CFS调度器的核心就是让虚 拟时间最小的进程最先运行， 一旦进程运行虚拟时间就会增加，最后尽量保证所有进程的 虚拟时间相等，谁小了就要多运行，谁大了就要暂停运行。

为什么要用红黑树来组织调度实体（进程实体）？
这是因为要维护虚拟时间的顺序，又要从中频繁的删除和插入调度实体，这种情况下红黑树这种结构无疑是非常好。

#### 线程
- 共享变量（解决了通讯麻烦的问题，但是对于变量的访问需要加锁）
- 调度由操作系统完成（由于共享内存，上下文切换变得高效）
- 一个进程可以有多个线程，每个线程会共享父进程的资源（创建线程开销占用比进程小很多，可创建的数量也会很多）
- 通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信（通过共享内存通信比通过内核要快很多）

#### 协程
- 调度完全由用户控制
- 一个线程（进程）可以有多个协程
- 每个线程（进程）循环按照指定的任务清单顺序完成不同的任务（当任务被堵塞时，执行下一个任务；当恢复时，再回来执行这个任务；任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量）
- 协程需要保证是非堵塞的且没有相互依赖
- 协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高

#### 总结
- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)
- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度

## 进程的状态
![[Pasted image 20220826160034.png]]
我们从这张图中可以看出来，在进程“活着”的时候就只有两个状态：运行态 （TASK_RUNNING）和睡眠态（TASK_INTERRUPTIBLE， TASK_UNINTERRUPTIBLE）。

运行态的意思是，无论进程是正在运行中（也就是获得了 CPU 资源），还是进程在 run queue 队列里随时可以运行，都处于这个状态。 我们想要查看进程是不是处于运行态，其实也很简单，比如使用 ps 命令，可以看到处于这 个状态的进程显示的是 R stat。

睡眠态是指，进程需要等待某个资源而进入的状态，要等待的资源可以是一个信号量 （Semaphore）, 或者是磁盘 I/O，这个状态的进程会被放入到 wait queue 队列里。

这个睡眠态具体还包括两个子状态：一个是可以被打断的（TASK_INTERRUPTIBLE），我 们用 ps 查看到的进程，显示为 S stat。还有一个是不可被打断的（TASK_UNINTERRUPTIBLE），用 ps 查看进程，就显示为 D stat。

除了上面进程在活的时候的两个状态，进程在调用 do_exit() 退出的时候，还有两个状态。 

一个是 EXIT_DEAD，也就是进程在真正结束退出的那一瞬间的状态；第二个是 EXIT_ZOMBIE 状态，这是进程在 EXIT_DEAD 前的一个状态，而我们今天讨论的僵尸进 程，也就是处于这个状态中。

#### 进程状态（TOP）
R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正 在等待运行。

D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
**不可中断状态**，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允 许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。

Z 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
**僵尸进程**表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状 态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有 正常处理子进程的退出。

S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件 而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。

I 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交 互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任 何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。

T 或者 t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。 向一个进程发送 SIGSTOP 信号，它就会因响应这个信号变成暂停状态（Stopped）；再向 它发送 SIGCONT 信号，进程又会恢复运行（如果进程是终端里直接启动的，则需要你用 fg 命令，恢复到前台运行）。而当你用调试器（如 gdb）调试一个进程时，在使用断点中断进程后，进程就会变成跟踪 状态，这其实也是一种特殊的暂停状态，只不过你可以用调试器来跟踪并按需要控制进程的 运行。

X，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令 中看到它。

## 僵尸进程
![[Pasted image 20220826165504.png]]
一个正常的进程退出流程是这样的：

-   子进程退出后，给父进程发送一个SIGCHLD的信号
-   父进程收到这个信号后，会通过wait系统调用来回收子进程

1. 僵尸进程产生原因：

僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源

当一个进程创建了一个子进程时，他们的运行是异步的。即父进程无法预知子进程会在什么时候结束，那么如果父进程很繁忙来不及wait 子进程时，那么当子进程结束时，会丢失子进程的结束时的状态信息，处于这种考虑unix提供了一种机制可以保证只要父进程想知道子进程结束时的信息，它就可以得到。

 这种机制是：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是仍然保留了一些信息，留下一个称为僵尸进程（Zombie）的数据结构（如进程号pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用wait/waitpid时才会释放。这样就导致了一个问题，如果没有调用wait/waitpid的话，那么保留的信息就不会释放。

**“僵死状态”，指的是子进程退出后，在父进程使用wait对它进行回收之前的状态**。

正常情况下，当一个进程创建了子进程 后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。 如果父进程没这么做，或是子进程执行太快，父进程还没来得及处理子进程状态，子进程就 已经提前退出，那这时的子进程就会变成僵尸进程。

通常，僵尸进程持续的时间都比较短，在父进程回收它的资源后就会消亡；或者在父进程退 出后，由 init 进程回收后也会消亡。 一旦父进程没有处理子进程的终止，还一直保持运行状态，那么子进程就会一直处于僵尸状 态。大量的僵尸进程会用尽 PID 进程号，导致新进程不能创建，所以这种情况一定要避 免。

2. 进程结束后为什么要进入僵尸状态?

因为父进程可能需要子进程的退出状态等信息。

3. 僵尸进程是每个子进程必经的状态吗？

是的。 任何一个子进程（init除外）在exit（）之后，并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit（）之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。

## 进程组和会话
进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员； 

会话是指共享同一个控制终端的一个或多个进程组。

比如，我们通过 SSH 登录服务器，就会打开一个控制终端（TTY），这个控制终端就对应 一个会话。而我们在终端中运行的命令以及它们的子进程，就构成了一个个的进程组，其中，在后台运行的命令，构成后台进程组；在前台运行的命令，构成前台进程组。

## 进程地址空间
我们用一张图，来表示进程的地址空间。图的左侧是说进程可以通过什么方式来更改进程 虚拟地址空间，而中间就是进程虚拟地址空间是如何划分的，右侧则是进程的虚拟地址空 间所对应的物理内存或者说物理地址空间。
![[Pasted image 20220905165136.png|700]]

应用程序都是跟虚拟地址打交道，不会直接跟物理地址 打交道。而虚拟地址最终都要转换为物理地址，由于 Linux 都是使用 Page（页）来进行管 理的，所以这个过程叫 Paging（分页）。

![[Pasted image 20220905165246.png|700]]
进程运行所需要的内存类型有很多种，总的来说，这些内存类型可以从是不是文件映射， 以及是不是私有内存这两个不同的维度来做区分，也就是可以划分为上面所列的四类内存。
**私有匿名内存**。进程的堆、栈，以及 mmap(MAP_ANON | MAP_PRIVATE) 这种方式 申请的内存都属于这种类型的内存。其中栈是由操作系统来进行管理的，应用程序无需 关注它的申请和释放；堆和私有匿名映射则是由应用程序（程序员）来进行管理的，它 们的申请和释放都是由应用程序来负责的，所以它们是容易产生内存泄漏的地方。 

**共享匿名内存**。进程通过 mmap(MAP_ANON | MAP_SHARED) 这种方式来申请的内 存，比如说 tmpfs 和 shm。这个类型的内存也是由应用程序来进行管理的，所以也可 能会发生内存泄漏。 

**私有文件映射**。进程通过 mmap(MAP_FILE | MAP_PRIVATE) 这种方式来申请的内存， 比如进程将共享库（Shared libraries）和可执行文件的代码段（Text Segment）映射到自己的地址空间就是通过这种方式。对于共享库和可执行文件的代码段的映射，这是 通过操作系统来进行管理的，应用程序无需关注它们的申请和释放。而应用程序直接通 过 mmap(MAP_FILE | MAP_PRIVATE) 来申请的内存则是需要应用程序自己来进行管 理，这也是可能会发生内存泄漏的地方。

**共享文件映射**。进程通过 mmap(MAP_FILE | MAP_SHARED) 这种方式来申请的内存， 我们在上一个模块课程中讲到的 File Page Cache 就属于这类内存。这部分内存也需要应用程序来申请和释放，所以也存在内存泄漏的可能性.


![[Pasted image 20220905165519.png|700]]
如上图所示，**Paging 的大致过程是**，CPU 将要请求的虚拟地址传给 MMU（Memory Management Unit，内存管理单元），然后 MMU 先在高速缓存 TLB（Translation Lookaside Buffer，页表缓存）中查找转换关系，如果找到了相应的物理地址则直接访 问；如果找不到则在地址转换表（Page Table）里查找计算。最终进程访问的虚拟地址就 对应到了实际的物理地址。

#### 进程内存管理
进程直接读写的都是虚拟地址，虚拟地址最终会通过 Paging（分页）来转换为物理内存 的地址，Paging 这个过程是由内核来完成的。

进程的内存类型可以从 anon（匿名）与 file（文件）、private（私有）与 shared（共 享）这四项来区分为 4 种不同的类型，进程相关的所有内存都是这几种方式的不同组 合。

查看进程内存时，可以先使用 top 来看系统中各个进程的内存使用概况，再使用 pmap 去观察某个进程的内存细节。
![[Pasted image 20220905210037.png|800]]

### tmpfs
我们知道，磁盘的速度是远远低于内存的，有些应用程序为了提升性能，会避免将一些无需持续化存储的数据写入到磁盘，而是把这部分临时数据写入到内存中，然后定期或者在不需要这部分数据时，清理掉这部分内容来释放出内存。在这种需求下，就产生了一种特殊的 Shmem：tmpfs。tmpfs 如下图所示：
![[Pasted image 20220905212758.png|700]]
它是一种内存文件系统，只存在于内存中，它无需应用程序去申请和释放内存，而是操作 系统自动来规划好一部分空间，应用程序只需要往这里面写入数据就可以了，这样会很方 便。我们可以使用 moun 命令或者 df 命令来看系统中 tmpfs 的挂载点。

很多应用程序会把日志保存在tmpfs里，也有些应用会把它的运行时文件保存在tmpfs里。比如systemd就会把日志记录到tmpfs中。你可以用mount命令来查看你的系统tmpfs挂载 路径，然后去这里面查看有哪些文件，你也可以看出来你的系统里有哪些应用会用到tmpfs.

## 进程的虚拟地址空间
进程的虚拟地址空间（address space）既包括用户地址空间，也包括内核地址空间。这可以简单地理解为，进程运行在用户态申请的内存，对应的 是用户地址空间，进程运行在内核态申请的内存，对应的是内核地址空间，如下图所示：
![[Pasted image 20220905214125.png|900]]
应用程序可以通过 malloc() 和 free() 在用户态申请和释放内存，与之对应，可以通过 kmalloc()/kfree() 以及 vmalloc()/vfree() 在内核态申请和释放内存。当然，还有其他申请 和释放内存的方法，但大致可以分为这两类。

从最右侧的物理内存中你可以看出这两类内存申请方式的主要区别，kmalloc() 内存的物理 地址是连续的，而 vmalloc() 内存的物理地址则是不连续的。这两种不同类型的内存也是 可以通过 /proc/meminfo 来观察的。

其中 vmalloc 申请的内存会体现在 VmallocUsed 这一项中，即已使用的 Vmalloc 区大 小；而 kmalloc 申请的内存则是体现在 Slab 这一项中，它又分为两部分，其中 SReclaimable 是指在内存紧张的时候可以被回收的内存，而 SUnreclaim 则是不可以被回 收只能主动释放的内存。