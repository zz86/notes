
## 信号
kill -l查看linux所有信号

如果我们按下键盘“Ctrl+C”，当前运行的进程就会收到一个信号 SIGINT 而退出；

如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号 SIGSEGV；

我们也可以通过命令 kill ，直接向一个进程发送一个信号，缺省情况下不指定信 号的类型，那么这个信号就是 SIGTERM。也可以指定信号类型，比如命令 “kill -9 ”, 这里的 9，就是编号为 9 的信号，SIGKILL 信号。

目前主流的 Linux 发行版，无论是 RedHat 系的还是 Debian 系的，都会把 /sbin/init 作 为符号链接指向 Systemd。Systemd 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程，也就是1号进程。

![[Pasted image 20220826111104.png]]
对 于 SIGKILL 和 SIGSTOP 这个两个信号，进程是不能忽略的。这是因为它们的主要作用是 为 Linux kernel 和超级用户提供删除任意进程的特权。对于捕获，SIGKILL 和 SIGSTOP 这两个信号也同样例外，这两个信号不能有用户自己的 处理代码，只能执行系统的缺省行为。这两个特权信号，不能被忽略也不能被捕获。

对于大部分的信号而言，应用程序不需要注册自己的 handler，使用系统缺省定义行为就 可以了。对于每个信号，用户进程如果不注册一个自己的 handler，就会 有一个系统缺省的 handler，这个缺省的 handler 就叫作 SIG_DFL。

![[Pasted image 20220826111951.png]]



## 并发操作中，linux解决数据同步的四种方法
#### 1.原子变量
在只有单个变量全局数据的情况下，这种变量非常实用，如全局计数器、状 态标志变量等。我们利用了 CPU 的原子指令实现了一组操作原子变量的函数。 

#### 2.中断的控制
当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在 单核心的 CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会 有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就 行了，为此我们开发了控制中断的函数。 

中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来 请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按 下了键盘上的某个按键、硬盘已经准备好了数据。

#### 3.自旋锁
由于多核心的 CPU 出现，控制中断已经失效了，因为系统中同时有多个代码执 行流，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待 最终获取锁。 

首先读取锁变量，判断其值是否已经加锁，如果 未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执 行后续步骤，因而得名自旋锁。

![[Pasted image 20220901091240.png|400]]
linux有多种自旋锁，例如原始自旋锁和排队自旋锁等

#### 4.信号量
如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都 不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获 取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让 CPU 能有时间 处理其它任务。所以信号量同时解决了三个问题：等待、互斥、唤醒。

Linux 中的信号量同样是用来保护共享资源，能保证资源在一个时刻只有一个进程使用，这 是单值信号量。也可以作为资源计数器，比如一种资源有五份，同时最多可以有五个进 程，这是多值信号量。

单值信号量，类比于私人空间一次只进去一个人，其信号量的值初始值为 1，而多值信号量，相当于是客厅，可同时容纳多个人。其信号量的值初始值为 5，就可容纳 5 个人。 

信号量的值为正的时候。所申请的进程可以锁定使用它。若为 0，说明它被其它进程占 用，申请的进程要进入睡眠队列中，等待被唤醒。所以信号量最大的优势是既可以使申请 失败的进程睡眠，还可以作为资源计数器使用。

#### 5.读写锁
在操作系统中，有很多共享数据，进程对这些共享数据要进行修改的情况很少，而读取的 情况却是非常多的，这些共享数据的操作基本都是在读取。 

如果每次读取这些共享数据都加锁的话，那就太浪费时间了，会降低进程的运行效率。因 为读操作不会导致修改数据，所以在读取数据的时候不用加锁了，而是可以共享的访问， 只有涉及到对共享数据修改的时候，才需要加锁互斥访问。 

想像一下 100 个进程同时读取一个共享数据，而每个进程都要加锁解锁，剩下的进程只能 等待，这会大大降低整个系统性能，这时候就需要使用一种新的锁了——读写锁。 

读写锁也称为共享 - 独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以 共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥）。 

读写锁非常适合读取数据的频率远大于修改数据的频率的场景中。这样可以在任何时刻， 保证多个进程的读取操作并发地执行，给系统带来了更高的并发度。 

那读写锁是怎么工作的呢？读写之间是互斥的，读取的时候不能写入，写入的时候不能读 取，而且读取和写入操作在竞争锁的时候，写会优先得到锁，步骤如下。 

1. 当共享数据没有锁的时候，读取的加锁操作和写入的加锁操作都可以满足。
2. 当共享数据有读锁的时候，所有的读取加锁操作都可以满足，写入的加锁操作不能满足，读写是互斥的。
3. 当共享数据有写锁的时候，所有的读取的加锁操作都不能满足，所有的写入的加锁操作 也不能满足，读与写之间是互斥的，写与写之间也是互斥的。

![[Pasted image 20220901094226.png|600]]

