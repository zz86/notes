
## 套接字（socket）
根据底层网络机制的差异，计算机网络世界中定义了不同协议族的套接字（socket），比 如 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix 套接字）、 CCITT X.25 地址（X.25 套接字）等。 

我们会重点讲解跟网络子系统和 TCP/IP 协议栈息息相关的一种套接字——Internet 套接 字。如果你对其他类型的套接字有兴趣，可以自行阅读这里的资料。 

Internet 套接字是 TCP/IP 协议栈中传输层协议的接口，也是传输层以上所有协议的实现。 

同时，套接字接口在网络程序功能中是内核与应用层之间的接口。TCP/IP 协议栈的所有数 据和控制功能都来自于套接字接口，与 OSI 网络分层模型相比，TCP/IP 协议栈本身在传输 层以上就不包含任何其他协议。 

在 Linux 操作系统中，替代传输层以上协议实体的标准接口，称为套接字，它负责实现传 输层以上所有的功能，可以说套接字是 TCP/IP 协议栈对外的窗口。 

Linux 套接字 API 适合所有的应用标准，现在的应用层协议也全部移植到了 Linux 系统 中。但请你注意，在套接字层下的基础体系结构实现却是 Linux 系统独有的，Linux 内核支持的套接字结构如图所示

![[Pasted image 20220905105317.png|700]]
我们创建套接字时，可以通过参数选择协议族，为应用程序指定不同的网络机制。如果指 定为 PF_INET 协议族，这里的套接字就叫做 INET 套接字，它的套接字接口函数提供了 TCP/IP 网络服务功能。

## 套接字信息
你可以用 netstat 或者 ss ，来查看套接字、网络 栈、网络接口以及路由表的信息。推荐使用 ss 来查询网络的连接信息，因为它比 netstat 提供了更好的性能（速 度更快）。

其中，接收队列（Recv-Q）和发送队列（Send-Q）需要特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。当然还要注意，在不同套接字状态 下，它们的含义不同。

当套接字处于连接状态（Established）时，

Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。

而 Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。

当套接字处于监听状态（Listening）时，

Recv-Q 表示 syn backlog 的当前值。

而 Send-Q 表示最大的 syn backlog 值。

而 syn backlog 是 TCP 协议栈中的半连接队列长度，相应的也有一个全连接队列（accept queue），它们都是维护 TCP 状态的重要机制。

顾名思义，所谓半连接，就是还没有完成 TCP 三次握手的连接，连接只进行了一半，而服 务器收到了客户端的 SYN 包后，就会把这个连接放到半连接队列中，然后再向客户端发送 SYN+ACK 包。

而全连接，则是指服务器收到了客户端的 ACK，完成了 TCP 三次握手，然后就会把这个连 接挪到全连接队列中。这些全连接中的套接字，还需要再被 accept() 系统调用取走，这 样，服务器就可以开始真正处理客户端的请求了。