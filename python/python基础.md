
#### 基础

- **assert** 断言，如果assert后面的条件为True则继续执行，否则抛出异常

- 字典和json字符串 相互转换
  - json.loads()
  - json.dumps()
  - 在flask中不建议使用json.dumps()，因为他的response headers里面的content-type是text/html
  - flask中应该使用jsonify()，他可以修改响应头中的content-type为application/json
  
- 动态导入模块：`module_name = __import__(xxx)`

- 到导入的模块对象中获取想要的函数引用：`function_name = getattr(module_name, function_name)`

- 函数的不定长参数：**kwargs，kwargs是一个传入的参数字典

- `__init__.py` 让一个文件夹变成python的包，然后才可以通过文件夹名引用里面的module

  - 在python3.3之前，这是必要的
  - 在python3.3之后，这是非必要的，但是依然建议这样写，因为在`__init__.py`里可以做一些初始化操作，因为`__init__.py`文件在该包被引入时会执行

- 全局变量用全大写，在函数内使用时需先声明  global
- 取用字典中的value   dict.get("key")

#### 内建函数

- python解释器运行时会自动的加载很多的常用的变量、函数以及类等

​	内建函数：Build-in Function，`dir(__builtin__)`查看所有内建函数

- range()函数在python2中返回一个列表，先全部生成再使用，在python3中返回一个可迭代对象，range对象，可以配合for或者next使用，用到哪个就生成哪个

#### 面向对象

- class定义类的时候，python实际上会进行调用执行的

- 多态
  1. 看上去调用的是相同的方法，但实际上要看，这个对象是父类还是子类创建的对象
  2. 如果是父类创建的对象，一定调用父类中定义的方法
  3. 如果是子类创建的对象，那么就要看子类中是否重写了父类的方法
     - 如果子类重写了父类中的方法，那么调用子类的方法
     - 如果子类没有重写父类中的方法，那么调用父类的方法

- 方法
  1. 实例方法，至少有一个self参数，执行实例方法时，自动将调用该方法的对象复制给self
  2. 类方法，`@classmethod`至少有一个cls参数，执行类方法时，自动将调用该方法的类赋值给cls
  3. 静态方法，无默认参数
  4. 方法其实也是一个属性

- 属性
  1. 类属性，属于类，通过类访问，在内容中只保存一份
  2. 实例属性，属于对象，通过对象访问，在每个对象中都要保存一份

- super
  1. super在调用父类时，需要计算出当前到底调用哪个父类，在python中实现这个功能的算法叫做C3
  2. 作用链要根据类的`__mro__`确定
  3. 为避免多继承报错，使用不定长参数

- 内建属性，魔法属性
  
  在使用类时，可以直接使用的那个功能，例如`__init__`、`__new__`等
  
  - `__getattr__`，`__getattribute__`都是对访问属性时的特殊操作，`__getattr__`当访问未定义的属性时进行拦截，这个方法里默认抛异常，可以自己重写，`__getattribute__`当访问所有属性都进行拦截。如果以上二者同时出现，会调用`__getattribute__`。
  - `__dict__`
    - 返回一个字典，存储类的所有属性
  
- 新式类 vs 经典类
  1. python3中定义的类都是新式类，无论是否写明继承object，都会间接或者直接继承object
  2. python2中写明继承object的是新式类，否则是经典类
  3. 新式类中自带了很多的功能

#### property属性

- 虽然看上去调用的是普通属性，或者给属性赋值，但实际上是调用某个指定的方法来获取数据或者设置数据，可以在这个方法中对数据进行校验，这种特殊的属性叫做`property`属性
- 装饰器`@property`使方法变成属性，经典类只有这一种方法
- 新式类还有`@xxx.setter`和`@xxx.deleter`，前提是有`@property`属性`def xxx(self, ...)`

- 另一种方法，xxx = property(`对象.属性`的方法，`对象.属性=xxx`的方法，`del 对象.属性`的方法，`对象.属性.__doc`__的方法)

#### 元类

- 

#### type hint

- python 常用的有关类型的静态分析工具有mypy

#### 垃圾回收

- 小整数对象池

  python解释器为了能让程序运行效率更快，将常用的数据，默认范围[-5, 256]，在python解释器运行之前就创建好了，供用户使用。这个范围称为小整数对象池。常驻内存

- 大整数不共用内存，引用计数为0，销毁

- intern机制（字符串驻留机制）

  默认对字符串开启intern机制，共用一份，但是如果字符串中包含空格等特殊字符，不会开启，各用各的

- GC垃圾回收

​	python采用的是引用计数机制为主，分代回收为辅的策略。

0,1,2代，（创建对象个数-清除对象个数）超过gc阈值后执行分代回收机制

在python中，分代回收把对象分为三代，对象在创建的时候，放在一代中，如果在一次一代的检查中，该对象存活下来，就会放到二代中，同理，在一次二代检查中，该对象存活下来就会放到三代中。

当0代垃圾数量超过阈值时执行0代清理，当0代清理次数超过阈值时执行1代清理，当1代清理次数超过阈值时执行2代清理。

#### 协程coroutine

- 通俗的理解，在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量信息，然后切换到另一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候切换到原来的函数都由开发者自己决定

- 线程和协程的差异：

- - 在实现多任务时，线程切换从系统层面远不止保存和恢复CPU那么简单。操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还帮你做这些数据的恢复操作，所以线程的切换非常耗性能，但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换上百万次系统都抗得住
  - 进程、线程创建完了之后，需要操作系统来计算让哪个进程、线程先执行（调度算法，例如优先级调度）
  - 协程是可以人为来控制的
  - 通过协程能够实现多任务，但是是假的多任务，不停的切换函数执行。多线程、多进程根据cpu核数不一定可能是并行的，但是协程是在一个线程中，所以是并发

- 使用yield实现协程

- 使用greenlet实现协程

- **使用gevent实现协程**

  可以自行切换协程指定的任务，切换的前提是：当一个任务用到耗时操作（例如延时），他就会把这个时间拿出来去做另外的任务

#### GIL（全局解释器锁）

- python中多线程是假的
- python解释器和GIL没有半毛钱关系，仅仅是由于历史原因（过去电脑都是单核）在Cpython虚拟机（解释器），难以移除GIL
- GIL：全局解释器锁：每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程可以执行代码
- 线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL，python3.x使用计时器（执行时间达到阈值后释放GIL），python2.x当tickets计数达到100时释放GIL
- 多线程爬取比单线程性能提升，因为遇到IO阻塞会自动释放GIL锁

#### 描述符

- property就是一个描述符
- 如果一个类中有如下3个方法中的任意一个，那么这个类创建的对象就是“描述符”对象
  - `__get__`
  - `__set__`
  - `__delete__`

- 在另外一个类中，定义一个类属性，指向一个描述符对象，且这个对象中有以上三个方法中的任意一个，则这个类属性就是一个描述符
  - 当获取这个类属性的时候，会自动调用`__get__`方法
  - 当设置这个类属性的时候，会自动调用`__set__`方法
  - 当删除这个类属性的时候，会自动调用`__delete__`方法

- 描述符的作用简言之就是调用类属性时，执行特定的方法

- 为什么要用描述符
  - 可以做类型检查
  - 比property属性更方便，多个property会造成代码冗余

- 描述符分为两种

  - 数据描述符（资料描述符）

    同时定义了`__get__`和`__set__`方法的描述符称为数据描述符（资料描述符）

  - 非数据描述符（非资料描述符）

    只定义了`__get__`的描述符称为非数据描述符（非资料描述符）

  - 二者的区别是：当属性和描述符名相同时，在访问同名属性时，如果是数据描述符就会先访问描述符，如果是非数据描述符就会先访问属性

- 只读描述符

  要想制作一个只读的资料描述符，需要同时定义`__get__`和`__set__`，并在`__set__`中引发一个AttributeError异常

- 描述符的原理

  由`obj.__getattribute__`方法决定，如果是普通属性就直接返回属性值，如果是一个描述符就调用描述符的`__get__`方法。如果`obj.__getattribute__`没有找到这个属性，会调用`__getattri__`方法，一般会产生一个异常。

```python
def __get__(self, instance, owner)

def __set__(self, instance, value)
```

- 注意事项
  - 不能将实例属性放到描述符，相当于这个属性指向了一个普通的对象，这个对象有`__get__`和`__set__`方法

#### 多任务编程

- 并发编程（不是并行）目前有四种方式：多进程、多线程、协程和异步。
  - 多进程编程在python中有类似C的os.fork,更高层封装的有multiprocessing标准库
  - 多线程编程python中有Thread和threading
  - 异步编程在linux下主+要有三种实现select，poll，epoll
  - 协程在python中通常会说到yield，关于协程的库主要有greenlet,stackless,gevent,eventlet等实现。

- 并发是一个假的多任务的描述，并行是一个真的多任务的描述
- 线程，是CPU调度和分派的基本单位
  - 用函数实现线程
  - 用类实现线程（常用）
    - 定义一个新的类，继承threading.Thread类，在这个类中实现run方法，在run方法中写要执行的代码，当使用这个类创建一个对象后，调用对象的start方法就可以让这个线程执行，而且会自动执行run方法代码。

- 队列
  - 队列Queue
  - 堆栈Queue
  - 优先级Queue

- 互斥锁

```python
#创建锁
mutex = threading.Lock()
#加锁
mutex.acquire()
#释放锁
mutex.release()
```

- 进程，是系统进行资源分配和调度的一个独立单位
  1. 用函数实现多进程，和用函数实现线程类似
  2. 用类实现进程，和用函数实现进程类似
  3. 进程池

- 进程间通信（IPC）

  - Queue`multiprocessing.Queue()`

    ......

- 进程池`multiprocessing.Poll()`

- 进程池间通信`multiprocessing.Manager().Queue()`

#### 网络编程

- 套接字
  - udp，每次都需要写接收方的ip和port
  - tcp，建立时需要写接收方的ip和port，发送数据时不需要
    1. 面向连接
    2. 可靠传输
       - TCP采用“发送-应答”机制
       - 有序数据传输
       - 超时重传以及舍弃重复数据包
       - 错误校验
       - 流量控制和阻塞管理
  
  - tcp长连接短连接：
    - 短连接：WEB网站的http服务
    - 长连接：网游，连接数据库（如果短连接频繁的通信会造成socket错误）

#### 异步编程

- 真的多任务叫并行，假的多任务叫并发

- 多进程适合计算密集型，多线程适合IO密集型

- asyncio.run()，asyncio.sleep()

- Task实现异步

- requests是同步的，aiohttp是异步的

  
