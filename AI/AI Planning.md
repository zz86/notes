
## 搜索算法的分类

**盲目 搜索 vs. 启发式（或者 有信息）搜索**：

-   盲目搜索算法：在一般搜索算法中仅使用基本的原始信息。
    -   例如：深度优先搜索（DFS）、宽度优先搜索（BFS）、一致代价搜索（Uniform Cost Search, UCS，例如：Dijkstra）、迭代深化搜索（Iterative Deepening Search, IDS）
-   启发式搜索算法：额外使用 启发式函数 估计到目标的距离（或剩余代价）。
    -   例如：A∗ 搜索、IDA∗ 搜索、爬山算法（Hill Climbing）、最佳优先搜索（Best First）、WA∗ 搜索、DFS B&B 算法、LRTA∗ 搜索……

**系统 搜索 vs. 局部 搜索**：

-   系统搜索算法：同时考虑大量搜索结点。
-   局部搜索算法：一次处理一个（或几个）候选解（搜索结点）。  
    → 这不是非黑即白的区别，可以存在混杂的情况。（例如，enforced hill-climbing）

-   **盲目搜索 vs. 启发式搜索**：
    -   对于达到最低满意度要求的规划，启发式搜索在任何情况下都大大优于盲目算法。
    -   对于最优规划，启发式搜索也更好。（但差异不太明显）
-   **系统搜索 vs. 局部搜索**：
    -   对于达到最低满意度要求的规划，两者都有一些成功的案例。
    -   对于最优规划，需要系统算法。

-   **盲目搜索 vs. 有信息搜索**
    -   盲目搜索 不需要除了问题本身以外的任何输入。
        -   优点：可以简单地直接从问题开始，不需要额外信息，不需要考虑启发函数等等。
        -   缺点：求解过程比较盲目，会生成大量扩展，实践中计算量很大，效率很低。
    -   有信息搜索 需要额外输入一个 启发函数 h，该函数将状态映射到它们 目标距离 的估计
        -   优点：在实践中，通常比盲目搜索更加高效
        -   缺点：需要 找到 / 实现 启发函数 h
        -   注意：在 规划 中，启发函数 h 是从声明式问题描述中自动生成的。
-   **关于盲目搜索，我们将讨论**：
    -   宽度优先搜索
        -   优势：时间复杂度
        -   变体：一致代价搜索（Uniform cost search）
    -   深度优先搜索
        -   优势：空间复杂度
    -   迭代加深搜索（Iterative deepening search.）
        -   结合了宽度优先搜索和使得优先搜索的优势
        -   子过程中使用了 深度受限搜索（depth-limited search）
-   **关于盲目搜索，我们不会讨论**：
    -   双向搜索（Bi-directional search）
        -   两个单独的搜索空间，一个从初始状态开始向前搜索，另一个从目标开始向后搜索。当两个搜索空间重叠时停止。

## 启发式搜索

**系统启发式搜索算法**：

-   贪婪最佳优先搜索（Greedy best-ﬁrst search）  
    → 满意规划（satisﬁcing planning）中最流行的 3 种算法之一。
-   加权 A∗  
    → 满意规划（satisﬁcing planning）中最流行的 3 种算法之一。
-   A∗  
    → 最优规划（optimal planning）中最流行的算法。（在满意规划中很少使用。）
-   还有很多，诸如 IDA∗、深度优先分支定界搜索（depth-ﬁrst branch-and-bound search）、宽度优先启发式搜索（breadth-ﬁrst heuristic search）等等。

**局部启发式搜索算法**：

-   爬山算法（Hill-climbing）
-   增强爬山算法（Enforced hill-climbing）  
    → 满意规划（satisﬁcing planning）中最流行的 3 种算法之一。
-   还有很多，诸如 波束搜索（Beam search）、禁忌搜索（tabu search）、遗传算法（genetic algorithms）、模拟退火（simulated annealing）等等。

## 几种搜索算法的性质对比
了解每种算法的优缺点是很重要的，下表给出了几种搜索算法的性质对比：
![[Pasted image 20220929154243.png]]
## 例子
![[Pasted image 20220929160616.png]]

## 如何解决规划问题
**关键问题：使用 PDDL 语言** 的两个主要好处：

-   说明：简洁的模型描述。  
    在前面的砖块世界的例子中，我们仅用非常短的 PDDL 文件就可以定义 domain，即便是很复杂的问题，我们也可以很容易地将其编码为 domain 文件来表示，这将带来诸多好处：因为否则的话，我们将不得不编写每一个单独的 **对象（object）和每一条单独的 规则（rule）**，PDDL 语言为我们提供了一种更灵活的选择。
-   计算：揭示有用的启发式信息（结构）  
    另一个问题是计算。语言让我们得以描述问题，使得程序可以理解问题的结构，并且在结构之外加入启发式信息。例如，在吃豆人问题中，我们可以在 PDDL 规划器之外加入启发式搜索来引导搜索树。

为了达到上述目的，通常有 **两种传统方法：搜索 vs. 分解

-   对状态模型 S(P) 直接进行 显式搜索，但是通常效率较低，直到最近才有所改善。  
    如今我们采用的最常见的方法是显示搜索：我们有初始状态、目标状态，以及搜索算法（例如：A∗ 算法）来发现从初始状态到目标状态的路径。
-   另一种方法是 分解（decomposition）问题。  
    相比只是找出一条从初始状态到目标状态的路径，我们试图将规划问题分解为一些启发式的子问题，如果我们可以找到这些子问题的解，我们可以将其组合，得到原规划问题的解。通常，这种方法更好一些，因为规划问题的状态空间通常很大，即使采用很好的启发式算法，搜索空间依然很大。

### 经典规划的计算方法

-   **通用问题求解器（General Problem Solver, GPS）和 Strips**（50-70 年代）：均值分析、分解、回归……
-   **偏序（Partial Order, POCL）规划**（80 年代）：处理任何开放的子目标、解决威胁；UCPOP 1992
-   **图规划（Graphplan）**（1995-2000）：建立包含一定长度内的所有可能的 **并行** 规划的图；然后通过从目标向后搜索整个图来提取规划。
-   **可满足性规划（Planning as Satisfiability, SATPlan）**（1996-）：将规划问题映射为 SAT 问题；使用最前沿的 SAT 求解器。
-   **启发式搜索规划（Heuristic Search Planning）**（1996-）：从问题 P 中提取的具有启发函数 h 的搜索状态空间 S(P)。
-   **模型检查规划（Model Checking Planning）**（1998-）：使用 “符号” 宽度优先搜索来搜索状态空间 S(P)，其中状态集由 BDD 实现的公式表示。

###  经典规划中的最新技术

-   自图规划以来取得重大 **进展**
-   **经验主义方法**
    -   标准 PDDL 语言
    -   提供规划器和基准；比赛
    -   专注于性能和可扩展性
-   **解决了大问题**（非最优）
-   不同的 **构想** 和 **想法**
    -   **启发式搜索** 规划
    -   **SAT** 规划
    -   **其他**：局部搜索（LPG），蒙特卡洛搜索（Arvand），…

这里，我们将主要关注启发式搜索规划，部分关注 SAT 规划。